# ExportExpressPro - Development Guide Part 2: Technical Implementation

---

## PHASE 1: FOUNDATION SETUP (Months 1-2)

### **1.1 Development Environment Setup**

#### **Project Structure:**
```
exportexpresspro/
‚îú‚îÄ‚îÄ desktop-app/              # Tauri application
‚îÇ   ‚îú‚îÄ‚îÄ src-tauri/           # Rust backend
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.rs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ export_manager/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ integrations/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îú‚îÄ‚îÄ src/                 # React frontend
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ hooks/
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ ai-engine/               # Python ML service
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ predictions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ market_analysis/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ data_processing/
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ website-integration/     # Website sync service
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sync/
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ shared/                  # Shared utilities and types
‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ constants/
‚îú‚îÄ‚îÄ docker-compose.yml       # Development environment
‚îî‚îÄ‚îÄ README.md
```

#### **Development Environment Setup:**
```bash
# Initialize the project
mkdir exportexpresspro && cd exportexpresspro

# Setup Tauri application
npm create tauri-app@latest desktop-app --template react-ts
cd desktop-app
npm install
npm install zustand @tanstack/react-query axios socket.io-client
npm install -D @types/node

# Setup Python AI engine
cd ../
mkdir ai-engine && cd ai-engine
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install fastapi uvicorn tensorflow pandas numpy scikit-learn
pip install pymongo redis websockets pydantic
pip freeze > requirements.txt

# Setup website integration service
cd ../
mkdir website-integration && cd website-integration
npm init -y
npm install express cors socket.io mongodb redis
npm install -D nodemon @types/node typescript

# Setup Docker environment
cd ../
touch docker-compose.yml
```

#### **Docker Compose Configuration:**
```yaml
# docker-compose.yml
version: '3.8'

services:
  mongodb:
    image: mongo:7.0
    container_name: exportpro_mongodb
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: password
    volumes:
      - mongodb_data:/data/db
      - ./init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:ro

  redis:
    image: redis:7.0-alpine
    container_name: exportpro_redis
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data

  ai-engine:
    build: ./ai-engine
    container_name: exportpro_ai
    ports:
      - "8001:8001"
    environment:
      - MONGODB_URL=mongodb://admin:password@mongodb:27017/exportpro?authSource=admin
      - REDIS_URL=redis://redis:6379
    depends_on:
      - mongodb
      - redis
    volumes:
      - ./ai-engine:/app
      - ai_models:/app/models

  website-sync:
    build: ./website-integration
    container_name: exportpro_sync
    ports:
      - "3001:3001"
    environment:
      - MONGODB_URL=mongodb://admin:password@mongodb:27017/exportpro?authSource=admin
      - REDIS_URL=redis://redis:6379
      - AI_ENGINE_URL=http://ai-engine:8001
    depends_on:
      - mongodb
      - redis
      - ai-engine

volumes:
  mongodb_data:
  redis_data:
  ai_models:
```

### **1.2 Unified Database Setup**

#### **MongoDB Initialization Script:**
```javascript
// init-mongo.js
db = db.getSiblingDB('exportpro');

// Create collections with validation
db.createCollection("products", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "category", "pricing", "inventory"],
      properties: {
        name: { bsonType: "string" },
        category: { bsonType: "string" },
        pricing: {
          bsonType: "object",
          required: ["base_cost", "current_price"],
          properties: {
            base_cost: { bsonType: "number" },
            current_price: { bsonType: "number" },
            predicted_price: { bsonType: "number" }
          }
        },
        inventory: {
          bsonType: "object",
          required: ["current_stock", "available"],
          properties: {
            current_stock: { bsonType: "number" },
            reserved: { bsonType: "number" },
            available: { bsonType: "number" }
          }
        }
      }
    }
  }
});

// Create indexes for performance
db.products.createIndex({ "category": 1, "pricing.current_price": 1 });
db.products.createIndex({ "name": "text", "category": "text" });
db.products.createIndex({ "market_intelligence.arbitrage_opportunities.market": 1 });

// Orders collection
db.createCollection("orders", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["order_number", "client", "products", "status_tracking"],
      properties: {
        order_number: { bsonType: "string" },
        status_tracking: {
          bsonType: "object",
          required: ["current_status"],
          properties: {
            current_status: { 
              bsonType: "string",
              enum: ["created", "processing", "sourcing", "documentation", 
                    "shipping", "delivered", "completed", "cancelled"]
            }
          }
        }
      }
    }
  }
});

db.orders.createIndex({ "order_number": 1 }, { unique: true });
db.orders.createIndex({ "status_tracking.current_status": 1 });
db.orders.createIndex({ "client.client_id": 1 });

// Suppliers collection
db.suppliers.createIndex({ "location.state": 1, "location.district": 1 });
db.suppliers.createIndex({ "products_offered.product_id": 1 });
db.suppliers.createIndex({ "performance_metrics.reliability_score": -1 });

// Market intelligence collection
db.market_intelligence.createIndex({ "product_id": 1, "timestamp": -1 });
db.market_intelligence.createIndex({ "arbitrage_opportunities.target_market": 1 });
db.market_intelligence.createIndex({ "timestamp": -1 });

// User authentication
db.users.createIndex({ "email": 1 }, { unique: true });

print("Database initialized successfully with collections and indexes");
```

### **1.3 Tauri Application Foundation**

#### **Rust Backend Setup (src-tauri/src/main.rs):**
```rust
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use tauri::{Builder, Context, Manager};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;

mod database;
mod export_manager;
mod api;
mod integrations;

use database::Database;
use export_manager::ExportManager;

#[derive(Debug, Serialize, Deserialize)]
struct AppState {
    db: Arc<Database>,
    export_manager: Arc<Mutex<ExportManager>>,
}

#[tauri::command]
async fn get_products(
    state: tauri::State<'_, AppState>,
    category: Option<String>
) -> Result<Vec<serde_json::Value>, String> {
    let products = state.db.get_products(category).await
        .map_err(|e| e.to_string())?;
    Ok(products)
}

#[tauri::command]
async fn create_order(
    state: tauri::State<'_, AppState>,
    order_data: serde_json::Value
) -> Result<String, String> {
    let mut export_manager = state.export_manager.lock().await;
    let order_id = export_manager.create_order(order_data).await
        .map_err(|e| e.to_string())?;
    Ok(order_id)
}

#[tauri::command]
async fn get_ai_predictions(
    state: tauri::State<'_, AppState>,
    product_id: String
) -> Result<serde_json::Value, String> {
    let predictions = state.db.get_predictions(&product_id).await
        .map_err(|e| e.to_string())?;
    Ok(predictions)
}

fn main() {
    let context = tauri::generate_context!();
    
    Builder::default()
        .setup(|app| {
            // Initialize database connection
            let db = Arc::new(Database::new("mongodb://localhost:27017/exportpro").unwrap());
            
            // Initialize export manager
            let export_manager = Arc::new(Mutex::new(ExportManager::new(db.clone())));
            
            // Store state
            app.manage(AppState {
                db,
                export_manager,
            });
            
            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            get_products,
            create_order,
            get_ai_predictions
        ])
        .run(context)
        .expect("error while running tauri application");
}
```

#### **Database Module (src-tauri/src/database.rs):**
```rust
use mongodb::{Client, Collection, Database as MongoDatabase};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::error::Error;

pub struct Database {
    client: Client,
    db: MongoDatabase,
}

impl Database {
    pub fn new(connection_string: &str) -> Result<Self, Box<dyn Error>> {
        let rt = tokio::runtime::Runtime::new()?;
        
        let client = rt.block_on(async {
            Client::with_uri_str(connection_string).await
        })?;
        
        let db = client.database("exportpro");
        
        Ok(Database { client, db })
    }
    
    pub async fn get_products(&self, category: Option<String>) -> Result<Vec<Value>, Box<dyn Error>> {
        let collection: Collection<Value> = self.db.collection("products");
        
        let filter = if let Some(cat) = category {
            doc! { "category": cat, "inventory.available": { "$gt": 0 } }
        } else {
            doc! { "inventory.available": { "$gt": 0 } }
        };
        
        let mut cursor = collection.find(filter, None).await?;
        let mut products = Vec::new();
        
        while let Some(doc) = cursor.next().await {
            products.push(doc?);
        }
        
        Ok(products)
    }
    
    pub async fn create_product(&self, product: Value) -> Result<String, Box<dyn Error>> {
        let collection: Collection<Value> = self.db.collection("products");
        let result = collection.insert_one(product, None).await?;
        Ok(result.inserted_id.to_string())
    }
    
    pub async fn get_predictions(&self, product_id: &str) -> Result<Value, Box<dyn Error>> {
        let collection: Collection<Value> = self.db.collection("market_intelligence");
        
        let filter = doc! { 
            "product_id": product_id,
            "timestamp": { "$gte": chrono::Utc::now() - chrono::Duration::hours(24) }
        };
        
        let options = FindOptions::builder()
            .sort(doc! { "timestamp": -1 })
            .limit(1)
            .build();
            
        if let Some(prediction) = collection.find_one(filter, options).await? {
            Ok(prediction)
        } else {
            Ok(serde_json::json!({"error": "No recent predictions found"}))
        }
    }
    
    pub async fn create_order(&self, order: Value) -> Result<String, Box<dyn Error>> {
        let collection: Collection<Value> = self.db.collection("orders");
        let result = collection.insert_one(order, None).await?;
        Ok(result.inserted_id.to_string())
    }
}

use mongodb::options::FindOptions;
use mongodb::bson::doc;
```

### **1.4 React Frontend Foundation**

#### **App Component (desktop-app/src/App.tsx):**
```typescript
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Toaster } from 'react-hot-toast';

// Components
import Sidebar from './components/Sidebar';
import Dashboard from './pages/Dashboard';
import Products from './pages/Products';
import Orders from './pages/Orders';
import Suppliers from './pages/Suppliers';
import MarketIntelligence from './pages/MarketIntelligence';
import Settings from './pages/Settings';

// Stores
import { useAppStore } from './stores/appStore';

// WebSocket connection
import { useWebSocket } from './hooks/useWebSocket';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      refetchOnWindowFocus: false,
    },
  },
});

function App() {
  const { isConnected } = useWebSocket();
  const { theme } = useAppStore();

  return (
    <QueryClientProvider client={queryClient}>
      <div className={`app ${theme}`}>
        <Router>
          <div className="flex h-screen bg-gray-100 dark:bg-gray-900">
            <Sidebar />
            <main className="flex-1 overflow-auto">
              <div className="p-6">
                {!isConnected && (
                  <div className="mb-4 p-3 bg-yellow-100 border border-yellow-400 text-yellow-700 rounded">
                    ‚ö†Ô∏è Real-time connection lost. Some features may be limited.
                  </div>
                )}
                
                <Routes>
                  <Route path="/" element={<Dashboard />} />
                  <Route path="/products" element={<Products />} />
                  <Route path="/orders" element={<Orders />} />
                  <Route path="/suppliers" element={<Suppliers />} />
                  <Route path="/market-intelligence" element={<MarketIntelligence />} />
                  <Route path="/settings" element={<Settings />} />
                </Routes>
              </div>
            </main>
          </div>
        </Router>
        
        <Toaster
          position="top-right"
          toastOptions={{
            duration: 4000,
            style: {
              background: theme === 'dark' ? '#1f2937' : '#ffffff',
              color: theme === 'dark' ? '#f9fafb' : '#111827',
            },
          }}
        />
      </div>
    </QueryClientProvider>
  );
}

export default App;
```

#### **App Store (desktop-app/src/stores/appStore.ts):**
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface AppState {
  // UI State
  theme: 'light' | 'dark';
  sidebarCollapsed: boolean;
  
  // Real-time Data
  products: Product[];
  orders: Order[];
  predictions: MarketIntelligence[];
  
  // Connection State
  isOnline: boolean;
  lastSync: Date | null;
  
  // Actions
  setTheme: (theme: 'light' | 'dark') => void;
  toggleSidebar: () => void;
  updateProducts: (products: Product[]) => void;
  updateOrders: (orders: Order[]) => void;
  updatePredictions: (predictions: MarketIntelligence[]) => void;
  setOnlineStatus: (status: boolean) => void;
  setLastSync: (date: Date) => void;
}

interface Product {
  _id: string;
  name: string;
  category: string;
  pricing: {
    current_price: number;
    predicted_price?: number;
  };
  inventory: {
    available: number;
  };
  market_intelligence?: {
    arbitrage_opportunities: Array<{
      market: string;
      potential_profit: number;
      confidence: number;
    }>;
  };
}

interface Order {
  _id: string;
  order_number: string;
  client: {
    company_name: string;
  };
  status_tracking: {
    current_status: string;
  };
  ai_analysis?: {
    predicted_total_profit: number;
    risk_score: number;
  };
}

interface MarketIntelligence {
  _id: string;
  product_id: string;
  predictions: {
    price_3_days: {
      value: number;
      confidence: number;
    };
  };
  arbitrage_opportunities: Array<{
    target_market: string;
    net_profit: number;
    confidence: number;
  }>;
}

export const useAppStore = create<AppState>()(
  persist(
    (set, get) => ({
      // Initial state
      theme: 'light',
      sidebarCollapsed: false,
      products: [],
      orders: [],
      predictions: [],
      isOnline: true,
      lastSync: null,
      
      // Actions
      setTheme: (theme) => set({ theme }),
      toggleSidebar: () => set((state) => ({ 
        sidebarCollapsed: !state.sidebarCollapsed 
      })),
      updateProducts: (products) => set({ 
        products, 
        lastSync: new Date() 
      }),
      updateOrders: (orders) => set({ 
        orders, 
        lastSync: new Date() 
      }),
      updatePredictions: (predictions) => set({ 
        predictions, 
        lastSync: new Date() 
      }),
      setOnlineStatus: (isOnline) => set({ isOnline }),
      setLastSync: (lastSync) => set({ lastSync }),
    }),
    {
      name: 'exportpro-app-storage',
      partialize: (state) => ({
        theme: state.theme,
        sidebarCollapsed: state.sidebarCollapsed,
      }),
    }
  )
);
```

#### **WebSocket Hook (desktop-app/src/hooks/useWebSocket.ts):**
```typescript
import { useEffect, useState } from 'react';
import { useAppStore } from '../stores/appStore';
import { toast } from 'react-hot-toast';
import io, { Socket } from 'socket.io-client';

export const useWebSocket = () => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  
  const { 
    updateProducts, 
    updateOrders, 
    updatePredictions,
    setOnlineStatus 
  } = useAppStore();

  useEffect(() => {
    // Connect to WebSocket server
    const socketConnection = io('http://localhost:3001', {
      autoConnect: true,
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
    });

    socketConnection.on('connect', () => {
      console.log('Connected to WebSocket server');
      setIsConnected(true);
      setOnlineStatus(true);
      toast.success('Real-time connection established');
    });

    socketConnection.on('disconnect', () => {
      console.log('Disconnected from WebSocket server');
      setIsConnected(false);
      setOnlineStatus(false);
      toast.error('Real-time connection lost');
    });

    // Handle real-time updates
    socketConnection.on('price_update', (data) => {
      console.log('Price update received:', data);
      // Update local store
      updateProducts(data.products);
      
      toast.success(
        `Price updated: ${data.product_name} ‚Üí ‚Çπ${data.new_price}`,
        { icon: 'üí∞' }
      );
    });

    socketConnection.on('arbitrage_opportunity', (data) => {
      console.log('Arbitrage opportunity:', data);
      updatePredictions([data]);
      
      toast.success(
        `üöÄ Arbitrage Opportunity: ${data.product_name} - Profit: ‚Çπ${data.profit_potential}`,
        { duration: 10000 }
      );
    });

    socketConnection.on('order_status_update', (data) => {
      console.log('Order status update:', data);
      updateOrders(data.orders);
      
      toast.info(
        `Order ${data.order_number}: ${data.new_status}`,
        { icon: 'üì¶' }
      );
    });

    socketConnection.on('market_alert', (data) => {
      console.log('Market alert:', data);
      
      toast.warning(
        `Market Alert: ${data.message}`,
        { duration: 8000, icon: '‚ö†Ô∏è' }
      );
    });

    setSocket(socketConnection);

    return () => {
      socketConnection.disconnect();
    };
  }, [updateProducts, updateOrders, updatePredictions, setOnlineStatus]);

  const emitMessage = (event: string, data: any) => {
    if (socket && isConnected) {
      socket.emit(event, data);
    } else {
      toast.error('Not connected to server');
    }
  };

  return {
    socket,
    isConnected,
    emitMessage,
  };
};
```

---

This completes Part 2 of the development guide. Part 3 will cover the AI engine implementation, market intelligence features, and advanced integration patterns.